package coursescheduler.client.daos;


import com.google.api.services.sheets.v4.Sheets;
import com.google.api.services.sheets.v4.model.ValueRange;
import coursescheduler.User;
import coursescheduler.infrastructure.database.DatabaseClient;

import java.io.IOException;
import java.security.GeneralSecurityException;
import java.util.Arrays;
import java.util.List;

/**
 * TODO: Javadoc.
 */
public final class BaseUserDao implements UserDao {
    private final Sheets service;
    private String spreadsheetId;



    public BaseUserDao(Sheets service, String spreadsheetId) throws IOException, GeneralSecurityException {
        this.service = service;
        this.spreadsheetId = spreadsheetId;
    }

    /**
     *
     * @param list 2D List of Objects generated by google sheets service api
     * @param toFind The string you want to find inside the 2D List of Objects
     * @return either the index of the Object that has the string, or -1 if not found
     */
    public Integer indexOfColumn(List<List<Object>> list, String toFind){
        int index = 0;
        for(; index<list.size(); index++){
            if(list.get(index).get(0).equals(toFind)){
                return index + 2; // change to 1 notation and skip header row
            }
        }
        return -1;
    }

    /**
     * @param list 2D List of Objects generated by google sheets service api
     * @param toFind The string you want to find inside the 2D List of Objects
     * @param startingIndex The starting index of the search
     * @return either the index of the Object that has the string, or -1 if not found
     */
    public Integer indexOfColumn(List<List<Object>> list, String toFind, int startingIndex){
        int index = startingIndex;
        for(; index<list.size(); index++){
            if(list.get(index).get(0).equals(toFind)){
                return index + 2; // change to 1 notation and skip header row
            }
        }
        return -1;
    }


    /**
     * @param sheet which sheet you want to fetch a column from
     * @param columnCharStart which 1st column you want to fetch via char index
     * @param columnCharFinal which final column you want to fetch via char index
     * @return A list object of all the elements of that column
     * @throws IOException
     */
    public List<List<Object>> getColumn(String sheet, char columnCharStart, char columnCharFinal) throws IOException {
        String userColumn = sheet+"!"+columnCharStart+"2:"+columnCharFinal; // 2 to end of column, skip header
        ValueRange userRange = service.spreadsheets().values().get(spreadsheetId, userColumn).execute();
        return userRange.getValues();
    }

    /**
     * @param email takes in a user email to find
     * @return returns the numerical index of that user as it appears in the remote google sheet
     * @throws IOException
     */
    public int findUserIndex(String email){
        // get a list of all the users and find the index of the email passed
        List<List<Object>> users = null;
        try {
            users = getColumn("CREDS", 'A', 'A');
        } catch (IOException e) {
            e.printStackTrace();
        }
        return indexOfColumn(users, email);
    }

    public boolean verifyUserLogin(String email, char[] password) throws IOException {
        int index = findUserIndex(email);
        if (index == -1) {
            return false;
        }
        // write password to column d
        // password = hash(password); this will need to be implemented
        ValueRange valueRange = new ValueRange().setValues(Arrays.asList(
                Arrays.asList(String.valueOf(password))
        ));
        service.spreadsheets().values().update(spreadsheetId, "CREDS!D" + index, valueRange).setValueInputOption("RAW").execute();

        // read column e boolean verify that compares password attempt and password saved
        boolean verified = Boolean.parseBoolean(service.spreadsheets().values().get(spreadsheetId, "CREDS!E" + index).execute().getValues().get(0).get(0).toString());

        // reset column d so previous attempts are not saved
        valueRange.getValues().get(0).set(0, "");
        service.spreadsheets().values().update(spreadsheetId, "CREDS!D" + index, valueRange).setValueInputOption("RAW").execute();

        return verified;
    }

    @Override
    public User addUser(User user, char[] password){

        if(user.getEmail() == null || password == null || user.getRole() == null || user.getEmail().equals("") || String.valueOf(password).equals("") || user.getRole().equals("")){
            return null;
        }

        // verify that the user being added does not already exist
        int index = 0;

        index = findUserIndex(user.getEmail());

        if(index == -1){
            return null;
        }

        // format for adding user to remote sheet
        ValueRange userValueRange = new ValueRange().setValues(Arrays.asList(
                Arrays.asList(user.getEmail(), String.valueOf(password), user.getRole(), "", "=AND(EXACT(B:B,D:D))")
        ));

        // adds user to next empty row
        try {
            service.spreadsheets().values().append(spreadsheetId, "CREDS!A1", userValueRange).setValueInputOption("USER_ENTERED").setInsertDataOption("INSERT_ROWS").execute();
        } catch (IOException e) {
            e.printStackTrace();
        }
        return user;
    }

    @Override
    public User getUserByEmail(String email){
        // find user
        int index = 0;

        index = findUserIndex(email);

        if(index == -1){
            return null;
        }
        // if user found, fetch information on the user and create a user object to return
        String userToGet = "CREDS!A"+index+":C"+index;
        ValueRange userRange  = null;
        try {
            userRange = service.spreadsheets().values().get(spreadsheetId, userToGet).execute();
        } catch (IOException e) {
            e.printStackTrace();
        }
        List<List<Object>> users = userRange.getValues();

        User user = new User( String.valueOf(users.get(0).get(0)), String.valueOf(users.get(0).get(2)), String.valueOf(users.get(0).get(0)));
        System.out.println(users+"\n\n\n"+user);
        return user;
    }

}
