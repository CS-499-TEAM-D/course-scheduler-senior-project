package coursescheduler.infrastructure.database;

import com.google.api.services.sheets.v4.Sheets;
import com.google.api.services.sheets.v4.model.*;
import coursescheduler.User;

import java.io.IOException;
import java.security.GeneralSecurityException;
import java.util.*;

/**
 * @author CSODOM
 */
public final class DatabaseClient {

    private static DatabaseClient dataBaseClientInstance = null;
    private final Sheets service;
    private final String spreadsheetId;
    private final int sectionLimit;
    private HashMap<String, Integer> sheetIDMap;

    /**
     *
     * Builds singleton object of the Sheets service object used to make API calls to the remote google sheet
     *
     * @throws IOException
     * @throws GeneralSecurityException
     */
    private DatabaseClient(int sectionLimit) throws IOException, GeneralSecurityException {
        // Build a new authorized API client service.
        // final String spreadsheetId = "1NNZsNlZRHzTG1w977LBTz_wVJ8YTYgJfLMPCSYWpE6Y"; // <-- LIVE DATA
        final String spreadsheetId = "17hrTlcbE9zvMlg8eH2Q7wsZjzXcCEqYfv_oVBqe4GKc"; // <-- TEST DATA
        Sheets service = SheetsServiceUtil.getSheetsService();
        this.service = service;
        this.spreadsheetId = spreadsheetId;
        this.sectionLimit = sectionLimit;
        updateSheetsIDList();
    }

    /**
     * @param sectionLimit limit the number of sections of a course that can be made
     * @return a singleton instance of the database client
     * @throws IOException
     * @throws GeneralSecurityException
     */
    public static DatabaseClient getInstance(int sectionLimit) throws IOException, GeneralSecurityException {
        return (dataBaseClientInstance == null) ? dataBaseClientInstance = new DatabaseClient(sectionLimit) : dataBaseClientInstance;
    }

    /**
     *
     * Updates a mapping of the sheet titles and their URL IDs, which is used for making calls to sheets that do not use ranges
     *
     * @throws IOException
     */
    public void updateSheetsIDList() throws IOException {
        HashMap<String, Integer> sheetIDMap = new HashMap<>();
        Sheets.Spreadsheets.Get thisSheet = service.spreadsheets().get(spreadsheetId);
        List<String> ranges = new ArrayList<>();
        thisSheet.setRanges(ranges);
        thisSheet.setIncludeGridData(false);
        Spreadsheet response = thisSheet.execute();
        List<Sheet> sheetList = response.getSheets();
        for(Sheet sheet : sheetList){
            sheetIDMap.put(sheet.getProperties().getTitle(), sheet.getProperties().getSheetId());
        }
        this.sheetIDMap = sheetIDMap;
    }


    /*
       =========== USER METHODS ===========
     */


    /**
     *
     * @param list 2D List of Objects generated by google sheets service api
     * @param toFind The string you want to find inside the 2D List of Objects
     * @return either the index of the Object that has the string, or -1 if not found
     */
    public Integer indexOfColumn(List<List<Object>> list, String toFind){
        int index = 0;
        for(; index<list.size(); index++){
            if(list.get(index).get(0).equals(toFind)){
                return index + 2; // change to 1 notation and skip header row
            }
        }
        return -1;
    }

    /**
     * @param list 2D List of Objects generated by google sheets service api
     * @param toFind The string you want to find inside the 2D List of Objects
     * @param startingIndex The starting index of the search
     * @return either the index of the Object that has the string, or -1 if not found
     */
    public Integer indexOfColumn(List<List<Object>> list, String toFind, int startingIndex){
        int index = startingIndex;
        for(; index<list.size(); index++){
            if(list.get(index).get(0).equals(toFind)){
                return index + 2; // change to 1 notation and skip header row
            }
        }
        return -1;
    }


    /**
     * @param sheet which sheet you want to fetch a column from
     * @param columnCharStart which 1st column you want to fetch via char index
     * @param columnCharFinal which final column you want to fetch via char index
     * @return A list object of all the elements of that column
     * @throws IOException
     */
    public List<List<Object>> getColumn(String sheet, char columnCharStart, char columnCharFinal) throws IOException {
        String userColumn = sheet+"!"+columnCharStart+"2:"+columnCharFinal; // 2 to end of column, skip header
        ValueRange userRange = service.spreadsheets().values().get(spreadsheetId, userColumn).execute();
        return userRange.getValues();
    }
    /**
     * @param email takes in a user email to find
     * @return returns the numerical index of that user as it appears in the remote google sheet
     * @throws IOException
     */
    public int findUserIndex(String email) throws IOException {
        // get a list of all the users and find the index of the email passed
        List<List<Object>> users = getColumn("CREDS", 'A', 'A');
        return indexOfColumn(users, email);
    }

    /**
     *
     * @param email username of the user to be returned
     * @return either the user object of the given username or null if not found
     * @throws IOException
     */
    public User getUserByName(String email) throws IOException {

        // find user
        int index = findUserIndex(email);
        if(index == -1){
            return null;
        }

        // if user found, fetch information on the user and create a user object to return
        String userToGet = "CREDS!A"+index+":C"+index;
        ValueRange userRange  = service.spreadsheets().values().get(spreadsheetId, userToGet).execute();
        List<List<Object>> users = userRange.getValues();

        User user = new User(String.valueOf(users.get(0).get(2)), String.valueOf(users.get(0).get(0)));
        System.out.println(users+"\n\n\n"+user);
        return user;
    }

    /**
     *  add a user listing to the remote google sheet
     * @param email email handle of user that will be their user name
     * @param password password for login verification
     * @param role short string logging what role the user has
     * @throws IOException
     */
    public void addUser(String email, char[] password, String role) throws IOException {
        if(email == null || password == null || role == null || email.equals("") || password.equals("") || role.equals("")){
            throw new IOException("Cannot add a user with missing data to the remote sheet");
        }

        // verify that the user being added does not already exist
        int index = findUserIndex(email);
        if(index == -1){
            throw new IOException("Cannot add new user with a username that already exists");
        }

        // format for adding user to remote sheet
        ValueRange userValueRange = new ValueRange().setValues(Arrays.asList(
                Arrays.asList(email, String.valueOf(password), role, "", "=AND(EXACT(B:B,D:D))")
        ));

        // adds user to next empty row
        service.spreadsheets().values().append(spreadsheetId, "CREDS!A1", userValueRange).setValueInputOption("USER_ENTERED").setInsertDataOption("INSERT_ROWS").execute();
    }



    /**
     * @param email user that wants to be verified
     * @param password the password submitted by the user that is compared against the remote password
     * @return returns the department that the user is in, or master if the master scheduler logged in, or FALSE if mismatch entry
     */
    public String verifyUserLogin(String email, char[] password) throws IOException {
        int index = findUserIndex(email);
        if(index == -1) {
            return "false";
        }
        // write password to column d
        // password = hash(password); this will need to be implemented
        ValueRange valueRange = new ValueRange().setValues(Arrays.asList(
                Arrays.asList(String.valueOf(password))
        ));
        service.spreadsheets().values().update(spreadsheetId, "CREDS!D"+index, valueRange).setValueInputOption("RAW").execute();

        // read column e boolean verify that compares password attempt and password saved
        boolean verified = Boolean.parseBoolean(service.spreadsheets().values().get(spreadsheetId, "CREDS!E"+index).execute().getValues().get(0).get(0).toString());

        // reset column d so previous attempts are not saved
        valueRange.getValues().get(0).set(0, "");
        service.spreadsheets().values().update(spreadsheetId, "CREDS!D"+index, valueRange).setValueInputOption("RAW").execute();

        if(verified){
            // return the role as a String
            return service.spreadsheets().values().get(spreadsheetId, "CREDS!C"+index).execute().getValues().get(0).get(0).toString();
        }
        return "false";
    }

    /*
       =========== COURSE METHODS ===========
     */


    /*
       =========== ALGORITHM METHODS ===========
     */

    /**
     * @return returns the sheet ID hashmap containing all the sheet ids and titles
     */
    public HashMap<String, Integer> getSheetIDMap(){
        return sheetIDMap;
    }
}

