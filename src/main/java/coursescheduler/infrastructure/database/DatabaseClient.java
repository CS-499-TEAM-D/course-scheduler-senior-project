package coursescheduler.infrastructure.database;

import com.google.api.services.sheets.v4.Sheets;
import com.google.api.services.sheets.v4.model.*;
import coursescheduler.infrastructure.database.objects.User;
import java.io.IOException;
import java.security.GeneralSecurityException;
import java.util.*;


public final class DatabaseClient {

    private final Sheets service;
    private final String spreadsheetId;
    private final int sectionLimit;
    private HashMap<String, Integer> sheetIDMap;

    /**
     *
     * Builds singleton object of the Sheets service object used to make API calls to the remote google sheet
     *
     * @throws IOException
     * @throws GeneralSecurityException
     */
    public DatabaseClient(int sectionLimit) throws IOException, GeneralSecurityException {
        // Build a new authorized API client service.
        // final String spreadsheetId = "1NNZsNlZRHzTG1w977LBTz_wVJ8YTYgJfLMPCSYWpE6Y"; // <-- LIVE DATA
        final String spreadsheetId = "17hrTlcbE9zvMlg8eH2Q7wsZjzXcCEqYfv_oVBqe4GKc"; // <-- TEST DATA
        Sheets service = SheetsServiceUtil.getSheetsService();
        this.service = service;
        this.spreadsheetId = spreadsheetId;
        this.sectionLimit = sectionLimit;
        updateSheetsIDList();
    }


    /**
     *
     * Updates a mapping of the sheet titles and their URL IDs, which is used for making calls to sheets that do not use ranges
     *
     * @throws IOException
     */
    public void updateSheetsIDList() throws IOException {
        HashMap<String, Integer> sheetIDMap = new HashMap<>();
        Sheets.Spreadsheets.Get thisSheet = service.spreadsheets().get(spreadsheetId);
        List<String> ranges = new ArrayList<>();
        thisSheet.setRanges(ranges);
        thisSheet.setIncludeGridData(false);
        Spreadsheet response = thisSheet.execute();
        List<Sheet> sheetList = response.getSheets();
        for(Sheet sheet : sheetList){
            sheetIDMap.put(sheet.getProperties().getTitle(), sheet.getProperties().getSheetId());
        }
        this.sheetIDMap = sheetIDMap;
    }


    /*
       =========== USER METHODS ===========
     */


    /**
     *
     * @param list 2D List of Objects generated by google sheets service api
     * @param toFind The string you want to find inside the 2D List of Objects
     * @return either the index of the Object that has the string, or -1 if not found
     */
    public Integer indexOfColumn(List<List<Object>> list, String toFind){
        int index = 0;
        for(; index<list.size(); index++){
            if(list.get(index).get(0).equals(toFind)){
                return index + 2; // change to 1 notation and skip header row
            }
        }
        return -1;
    }

    /**
     * @param list 2D List of Objects generated by google sheets service api
     * @param toFind The string you want to find inside the 2D List of Objects
     * @param startingIndex The starting index of the search
     * @return either the index of the Object that has the string, or -1 if not found
     */
    public Integer indexOfColumn(List<List<Object>> list, String toFind, int startingIndex){
        int index = startingIndex;
        for(; index<list.size(); index++){
            if(list.get(index).get(0).equals(toFind)){
                return index + 2; // change to 1 notation and skip header row
            }
        }
        return -1;
    }
    /**
     * @param sheet which sheet you want to fetch a column from
     * @param columnChar which column you want to fetch via char index
     * @return A list object of all the elements of that column
     * @throws IOException
     */
    public List<List<Object>> getColumn(String sheet, char columnChar) throws IOException {
        String userColumn = sheet+"!"+columnChar+"2:"+columnChar; // 2 to end of column, skip header
        ValueRange userRange = service.spreadsheets().values().get(spreadsheetId, userColumn).execute();
        return userRange.getValues();
    }


    /**
     * @param email takes in a user email to find
     * @return returns the numerical index of that user as it appears in the remote google sheet
     * @throws IOException
     */
    public int findUserIndex(String email) throws IOException {
        // get a list of all the users and find the index of the email passed
        List<List<Object>> users = getColumn("CREDS", 'A');
        return indexOfColumn(users, email);
    }

    /**
     *
     * @param email username of the user to be returned
     * @return either the user object of the given username or null if not found
     * @throws IOException
     */
    public User getUserByName(String email) throws IOException {

        // find user
        int index = findUserIndex(email);
        if(index == -1){
            return null;
        }

        // if user found, fetch information on the user and create a user object to return
        String userToGet = "CREDS!A"+index+":C"+index;
        ValueRange userRange  = service.spreadsheets().values().get(spreadsheetId, userToGet).execute();
        List<List<Object>> users = userRange.getValues();

        User user = new User(users.get(0).get(0), users.get(0).get(1), users.get(0).get(2));
        System.out.println(users+"\n\n\n"+user);
        return user;
    }

    /**
     *  add a user listing to the remote google sheet
     * @param username email handle of user that will be their user name
     * @param password password for login verification
     * @param role short string logging what role the user has
     * @throws IOException
     */
    public void addUser(String username, String password, String role) throws IOException {
        if(username == null || password == null || role == null || username.equals("") || password.equals("") || role.equals("")){
            throw new IOException("Cannot add a user with missing data to the remote sheet");
        }

        // verify that the user being added does not already exist
        int index = findUserIndex(username);
        if(index == -1){
            throw new IOException("Cannot add new user with a username that already exists");
        }

        // format for adding user to remote sheet
        ValueRange userValueRange = new ValueRange().setValues(Arrays.asList(
              Arrays.asList(username, password, role, "", "=AND(EXACT(B:B,D:D))")
        ));

        // adds user to next empty row
        service.spreadsheets().values().append(spreadsheetId, "CREDS!A1", userValueRange).setValueInputOption("USER_ENTERED").setInsertDataOption("INSERT_ROWS").execute();
    }

    /**
     * Alternative overload for adding a user with the user object instead of the individual fields
     * @param user user object containing user fields
     * @throws IOException
     */
    public void addUser(User user) throws IOException {
        if(user == null){
            throw new IOException("Cannot add a null user to the remote sheet");
        }
        addUser(user.getName(), user.getPass(), user.getRole());
    }

    /**
     * @param username user that wants to be verified
     * @param password the password submitted by the user that is compared against the remote password
     * @return true if the password inputted matches with remote password, else false
     */
    public boolean verifyUserLogin(String username, String password) throws IOException {
        int index = findUserIndex(username);
        if(index == -1) {
            return false;
        }
        // write password to column d
        // password = hash(password); this will need to be implemented
        ValueRange valueRange = new ValueRange().setValues(Arrays.asList(
                Arrays.asList(password)
        ));
        service.spreadsheets().values().update(spreadsheetId, "CREDS!D"+index, valueRange).setValueInputOption("RAW").execute();

        // read column e boolean verify that compares password attempt and password saved
        boolean verified = Boolean.parseBoolean(service.spreadsheets().values().get(spreadsheetId, "CREDS!E"+index).execute().getValues().get(0).get(0).toString());

        // reset column d so previous attempts are not saved
        valueRange.getValues().get(0).set(0, "");
        service.spreadsheets().values().update(spreadsheetId, "CREDS!D"+index, valueRange).setValueInputOption("RAW").execute();
        return verified;
    }

    /*
       =========== COURSE METHODS ===========
     */

    /**
     * @param departmentId department prefix code, specificying which sheet to add courses too
     * @param courseId the numerical course id
     * @param numberOfSections the number of sections for the course you would like to make
     * @return return true after a successful add, or false if the course already exists
     * @throws IOException
     */
    public boolean addCourse(String departmentId, int courseId, int numberOfSections) throws IOException {
        if(numberOfSections>sectionLimit){
            System.out.println("Section Limit for each course is set to 10");
            return false;
        }
        // attempt to add the course, if the department sheet does not exist, catch exception and make new department sheet and try again
        try{
            // first check that the course already does not exist in the department
            Vector<Integer> courseIndexes = findCourseIndex(departmentId, courseId);
            if(courseIndexes.isEmpty()) { // if the first index is -1 then the course does not exist
                List<List<Object>> row = new ArrayList<>();
                // create a new row for each course and record its section
                for(int i = 0; i < numberOfSections; i++){
                    row.add(Arrays.asList(courseId, i+1, "", "", "", 0, 0));
                }
                ValueRange valueRange = new ValueRange().setValues(row);
                service.spreadsheets().values().append(spreadsheetId, departmentId + "!A1", valueRange).setValueInputOption("RAW").execute();
                return true;
            }
            System.out.println("Course already exists!!!");
            return false;
        }catch(Exception e){
            if(e.getMessage().equals("java.lang.NullPointerException")){
                return false;
            }
            addDepartmentSheet(departmentId);
            return addCourse(departmentId, courseId, numberOfSections);
        }
    }

    /**
     * @param departmentId the department that the course is located in
     * @param courseId the course that you want all sections to be removed off
     * @throws IOException
     */
    public void removeCourse(String departmentId, int courseId) throws IOException {
        // get list of all index occurences of the course to delete
        Vector<Integer> courseIndexes = findCourseIndex(departmentId, courseId);
        if(courseIndexes.get(0) == -1){
            System.out.println("Course does not exist, cannot remove");
            return;
        }
        // create delete request and execute
        BatchUpdateSpreadsheetRequest deleteRequest = new BatchUpdateSpreadsheetRequest();
        Request request = new Request()
                .setDeleteDimension(new DeleteDimensionRequest()
                        .setRange(new DimensionRange()
                                .setSheetId(sheetIDMap.get(departmentId))
                                .setDimension("ROWS")
                                .setStartIndex(courseIndexes.get(0)-1)
                                .setEndIndex(courseIndexes.get(courseIndexes.size()-1))
                            )
                    );
        List<Request> requests = new ArrayList<Request>();
        requests.add(request);
        deleteRequest.setRequests(requests);
        service.spreadsheets().batchUpdate(spreadsheetId, deleteRequest).execute();

    }

    /**
     * @param departmentId department that the course is located in
     * @param courseId the course that you want to have removed
     * @param sectionId the specific section of the course that you want to have removed
     * @throws IOException
     */
    public void removeCourse(String departmentId, int courseId, int sectionId) throws IOException {
        // fetch a index list of all the row index occurences off the course
        Vector<Integer> courseIndexes = findCourseIndex(departmentId, courseId);
        if(courseIndexes.get(0) == -1){
            System.out.println("Course does not exist, cannot remove");
            return;
        }
        // fetch the section id column, check the course indexes and find the index of the course and section
        int indexOfCourseToDelete = findCourseIndex(departmentId, courseId, sectionId);
        if(indexOfCourseToDelete == -1){
            return;
        }
        // create delete course request and execute
        BatchUpdateSpreadsheetRequest deleteRequest = new BatchUpdateSpreadsheetRequest();
        Request request = new Request()
                .setDeleteDimension(new DeleteDimensionRequest()
                        .setRange(new DimensionRange()
                                .setSheetId(sheetIDMap.get(departmentId))
                                .setDimension("ROWS")
                                .setStartIndex(indexOfCourseToDelete-1)
                                .setEndIndex(indexOfCourseToDelete)
                        )
                );
        List<Request> requests = new ArrayList<Request>();
        requests.add(request);
        deleteRequest.setRequests(requests);
        service.spreadsheets().batchUpdate(spreadsheetId, deleteRequest).execute();
    }

    /**
     * @param departmentId the department you want to index a course for
     * @param courseId the course you want to find all of the indexes for
     * @return a vector listing of all the index occurrences of a course, or the first element will be -1 if there are none
     * @throws IOException
     */
    public Vector<Integer> findCourseIndex(String departmentId, int courseId) throws IOException {
        // returns a column of all the courses
        List<List<Object>> courseColumn = getColumn(departmentId, 'A');
        Vector<Integer> indexVector = new Vector<>();
        // if the department sheet is empty, and there are no courses in the course column, return -1 did not find course
        if(courseColumn == null){
            return indexVector;
        }
        // fetches index of first linear appearance
        int index = indexOfColumn(courseColumn, String.valueOf(courseId));
        indexVector.add(index);
        int safeCounter = 0;
        // fetches more indexes until the end of the column is reached, or if more than 10 loops occur
        while(index != -1 && safeCounter < 10){
            index = indexOfColumn(courseColumn, String.valueOf(courseId), index-1); // convert the index back to 0th notation minus the header plus start at next element of the column
            indexVector.add(index);
            safeCounter++;
        }
        indexVector.remove(indexVector.size()-1);
        return indexVector;
    }

    /**
     * @param departmentId the department you want to index a course for
     * @param courseId the course you want to find the section of
     * @param sectionId the section you want to get the index of
     * @return integer index of the course section, or -1 if not found
     * @throws IOException
     */
    public Integer findCourseIndex(String departmentId, int courseId, int sectionId) throws IOException {
        // returns list of all course indexes
        Vector<Integer> courseIndexes = findCourseIndex(departmentId, courseId);
        if(courseIndexes.get(0) == -1){
            return -1;
        }

        // fetch the section id column, check the course indexes and find the index of the course and section
        List<List<Object>> sectionColumn = getColumn(departmentId, 'B');
        int indexOfSection = -1;
        for(Integer index : courseIndexes){
            // the reason we do - 2 is we have to convert the row index to 0th notation minus header
            if(sectionColumn.get(index-2).get(0).equals(String.valueOf(sectionId))){
                indexOfSection = index;
                break;
            }
        }
        // break if section not found
        if(indexOfSection == -1){
            return -1;
        }
        return indexOfSection;
    }

    /**
     * @param departmentId sheet title
     * @throws IOException
     */
    public void addDepartmentSheet(String departmentId) throws IOException {
        ValueRange header = new ValueRange().setValues(Arrays.asList(
                Arrays.asList("course_id","section_num","professor","classroom_location","time_id","prelim_enr","max_enr") // this is the header for each department table
        ));
        List<Request> requests = new ArrayList<>();
        requests.add(new Request().setAddSheet(new AddSheetRequest().setProperties(new SheetProperties().setTitle(departmentId))));

        BatchUpdateSpreadsheetRequest body = new BatchUpdateSpreadsheetRequest().setRequests(requests);
        service.spreadsheets().batchUpdate(spreadsheetId, body).execute();

        service.spreadsheets().values().update(spreadsheetId, departmentId+"!A1", header).setValueInputOption("RAW").execute();

    }

    /**
     * Removes a given department sheet based off of input
     *
     * @param departmentId sheet title that will be converted into a sheetId
     * @return returns true if the department sheet was able to be deleted, false if not
     * @throws IOException
     */
    public boolean deleteDepartmentSheet(String departmentId) throws IOException {
        List<Request> requests = new ArrayList<>();
        Integer sheetId = this.sheetIDMap.get(departmentId);
        if(sheetId == null){
            return false;
        }
        requests.add(new Request().setDeleteSheet(new DeleteSheetRequest().setSheetId(sheetId)));
        BatchUpdateSpreadsheetRequest body = new BatchUpdateSpreadsheetRequest().setRequests(requests);
        service.spreadsheets().batchUpdate(spreadsheetId, body).execute();
        return true;
    }


    /**
     * @param departmentId department id of the course
     * @param courseId the course id
     * @param sectionId the section id
     * @param newValue the new value you want max enroll to be
     */
    public void adjustMaxEnrollment(String departmentId, int courseId, int sectionId, int newValue) throws IOException {
        int index = findCourseIndex(departmentId, courseId, sectionId);
        ValueRange value = new ValueRange().setValues(Arrays.asList(
                Arrays.asList(newValue)
        ));
        service.spreadsheets().values().update(spreadsheetId, departmentId+"!G"+index, value).setValueInputOption("RAW").execute();
    }


    /**
     * @param departmentId department id of the course
     * @param courseId the course id
     * @param sectionId the section id
     * @param newValue the new value you want preliminary enroll to be
     */
    public void adjustPreliminaryEnrollment(String departmentId, int courseId, int sectionId, int newValue) throws IOException {
        int index = findCourseIndex(departmentId, courseId, sectionId);
        ValueRange value = new ValueRange().setValues(Arrays.asList(
                Arrays.asList(newValue)
        ));
        service.spreadsheets().values().update(spreadsheetId, departmentId+"!F"+index, value).setValueInputOption("RAW").execute();
    }

    /*
       =========== ALGORITHM METHODS ===========
     */

}

